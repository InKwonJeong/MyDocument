# 운영체제

## 프로세스와 스레드의 차이

### 프로그램
 - 어떤 작업을 위해 실행할 수 있는 파일(.exe)

### 프로세스
![process](./image/process.png)
 - 실행된 프로그램
 - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
 - 운영체제로부터 시스템 자원(Code, Data, Stack, Heap)을 할당받는 작업의 단위

#### 특징
 1. 프로세스는 운영체제로부터 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다
 2. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다
 3. 다른 프로세스의 자원에 접근할 수 없다
 4. 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)을 사용해야 한다

### 스레드
![thread][./image/thread.png]
 - 프로세스 내에서 실행되는 여러 흐름의 단위
 - 프로세스가 할당받은 자원을 이용하는 실행의 단위

#### 특징
 1. 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다
 2. Code, Data, Heap 영역을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다

## Context Switching
 - CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때
 - 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체한다

### Context
 - Context는 CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들
 - Context는 프로세스의 PCB(Process Control Block)에 저장된다
 - Context Switching 때 해당 CPU는 아무런 일을 하지 못한다
 - 따라서, 컨텍스트 스위칭이 잦아지면 오히려 오버헤드가 발생해 효율(성능)이 떨어진다

### PCB 저장 정보
 - 프로세스 상태 : 생성, 준비, 수행, 대기, 중지
 - 프로그램 카운터(PC) : 프로세스가 다음에 실행할 명령어 주소
 - 레지스터 : 누산기, 스택, 색인 레지스터
 - 프로세스 번호

## 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
 1. 자원의 효율성 증대
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어든다
  - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다

 2. 처리 비용 감소 및 응답 시간 단축
  - 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적다(스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문)
  - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다(Context Switching시 스레드는 Stack 영역만 처리하기 때문)

## Thread-Safe
 - 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다
 - 공유 자원에 접근하는 프로그램 코드 부분(임계구역, Critical Section)을 동기화 기법으로 제어해줘야 한다(Mutex, Semaphore)

### Mutex
 - 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것
 - 임계영역에 들어갈 때 락(lock)을 걸어 다른 프로세스(혹은 쓰레드)가 접근하지 못하도록 하고, 임계영역에서 나와 해당 락을 해제(unlock)한다

### Semaphore
 - 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
 - 동시에 접근할 수 있는 리소스의 상태(수)를 나타내는 카운터

### Mutex VS Semaphore
 1. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없다(Mutex는 Counter가 1인 Binary Semaphore)
 2. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 진다
 3. Mutex의 경우 Mutex를 소유하고 있는 쓰레드만 Mutex를 해제할 수 있지만 Semaphore의 경우 Semaphore를 소유하지 않는 쓰레드도 Semaphore를 해제할 수 있다

## 동기와 비동기

### 동기
 - 여러 프로세스가 데이터를 주고 받을 때, 주고 받는 순서(또는 시간)가 일정하다는 것을 뜻한다
 - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행한다
 - 요청과 결과가 동시에 일어난다

### 비동기
 - '동기'가 아닌 것
 - 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 기다리지 않고 다음 작업을 수행한다
 - 요청과 결과가 동시에 일어나지 않는다

## 교착상태
 - 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

### 교착상태 4가지 조건
 1. 상호 배제
  - 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다

 2. 점유 대기
  - 하나 이상의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다

 3. 비선점
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다

 4. 환형 대기
  - 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어야 한다

### 교착상태 방지
 - 위 4가지 조건 중 하나라도 충족되지 않으면 교착상태는 발생할 수 없다

 1. 예방기법
  - 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법
  - 상호배제 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다
  - 점유대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당하거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다
  - 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다
  - 환형 대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다

 2. 회피기법
  - 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법
  - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사한다

 3. 발견기법
  - 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 방법

 4. 회복기법
  - 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 방법
